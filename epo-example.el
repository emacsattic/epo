;;; -*- Emacs-Lisp -*-
;;; EPO Sample Definition File for Language Dependent Information 
;;; (c)2001-2002 by HIROSE Yuuji [yuuji@ae.keio.ac.jp]
;;; Last modified Mon Feb  4 13:12:14 2002 on firestorm

;;[Commentary]
;;	
;;	EPOの言語依存設定のサンプル。
;;	これを新しい言語の設定見本として使って下さい。
;;	この例では新しい言語が "example" という名前であると仮定します。
;;	
;; 
;; 【ファイルの作成】
;; 
;; 新しい言語用の設定は、epo- の後ろに言語名を付けた名前のファイルに格納
;; します。つまり、言語が "example" ならファイル名を epo-example.el と
;; します。より正確にいうと、その言語を編集するメジャーモードの名前に依
;; 存します。
;; 
;;;
;; ========== Variables for Input Aider(EPOI) ==========
;;;
;; 【構造入力の補完テンプレート用alist】
;; 
;; ある言語特有の構造を補完入力する情報は Emacs-Lisp 変数
;; 
;;	epo-言語名-structure-alist
;; 
;; に設定します。
;; alistは (任意の1文字 補完リスト) が続く組合せで、「任意の1文字」は
;; その構造を補完するときの入力キーとして利用されます。必ず一意にします。
;; 「補完リスト」は要素として 'type, 'structure, 'argsep, 'table,
;; 'mustmatch, 'arg-reader を含むalistです。'argsep 以降は省略可能です。
;;
;; * type	構造の種別を示すシンボル。メニューの一覧の文字に使われます。
;;		一意に定まる任意の名前をシンボルで指定して下さい。
;; * structure	構造を入力するときの流れを指定するリストを指定します。固
;;		定的な文字列をバッファに入力するときは文字列をそのまま書
;;		きます。文字列以外に以下のシンボルが使えます。
;;		- 'keyword	構文の鍵となる単語が来る位置を指定します。
;;		  この部分の入力に対しては補完入力が適用されます。
;;		- 'argument 	構文に与える引数が来る位置を指定します。
;;		  この部分の入力に対しては通常の文字列入力が適用されます。
;;		  構造補完入力時に何も入力しなかった場合はこの位置にカー
;;		  ソルが来ます。
;;		- 'cursor	構造入力が終わったときにカーソルを置く位置
;;		  を指定します。'argumentに何も入れなかった場合はその位
;;		  置になる場合があります。
;;		- 'indent	そこまでの入力が終わった時点でその行のイ
;;		  ンデントを施します。ただし、メジャーモードがインデント
;;		  機能を提供していない場合は期待した通りに動きません。
;; * argsep	ちょっと難しいですよ:-)
;;		その構造に与える引数を区切る文字列を、長さ6のリストで指
;;		定します。
;;		1. 並び開始記号
;;		   引数並びが存在するとき並び全体の先頭(左側)に来る文字列
;;		   引数がないときには省略されるような開始記号なので、C言
;;		   語の関数引数をくくる括弧はこれには相当しません。
;;		2. 要素開始記号
;;		   一つの引数の値の左側に来る文字列
;;		3. 要素代入記号
;;		   引数渡しが値代入方式(連想配列方式)である場合に、代入
;;		   を意味する文字列。HTMLの各エレメントの属性の場合は
;;		   "=" であり、Perlの連想配列の場合は "=>" となります。
;;		   値代入方式ではなく、一般的な順序依存渡しである場合
;;		   は、必ず nil を指定します(""ではだめ)。
;;		4. 要素区切り記号
;;		   引数が複数あるときに、それらを区切る文字列を指定しま
;;		   す。C言語系の場合は "," です。Lisp系なら " " でしょう。
;;		5. 要素終端記号
;;		   一つの引数の値の右側に来る文字列
;;		6. 並び終端記号
;;		   引数並びが存在するとき並び全体の末尾(右側)に来る文字列
;;	
;;		代表的な言語では以下のようになります。
;;	
;;		- Cの関数参照		"" "" nil ", " "" ""
;;		- HTMLの属性指定	" " "\"" "=" " " "\"" ""
;;		- Perlの連想渡し	"{" "" "=>" "," "" "}"
;;	
;;		ただ、やはり argsep を記述するのは難しいので、簡単なシン
;;		ボルで典型的な言語の引数区切り情報を表せるようにしました。
;;	
;;		(argsep . c-function)	;;Cの関数呼び出しの括弧内方式
;;		(argsep . latex)	;;LaTeXの\begin直後与える引数方式
;;		(argsep . c-function)	;;Cの関数呼び出しの括弧内方式
;;		(argsep . sgml)		;;SGML(HTMLなど)の属性渡し記法
;;		(argsep . lisp)		;;Lispの関数呼び出しの方式
;;		(argsep . perl-hash)	;;Perl5の連想渡し型式
;;	
;; * table	構造の 'keyword の候補となる単語を alist 形式で指定します。
;;		alistのcdr部に文字列を指定した場合は、引数の入力時にその
;;		文字列がプロンプトとして利用されます。
;;		alistそのものでなく、シンボルを与えるとそのシンボルが持
;;		つ値を利用します。候補が多数になる場合には別の変数に定義
;;		する方が良いでしょう。
;;	
;; * mustmatch	構造の 'keyword の候補となる単語を補完入力する場合に、候
;;		補に存在するものしか入力を受け付けない場合に t にセット
;;		します。
;; * arg-reader	引数を入力するときに特別に利用したい関数があればそれを指
;;		定します。その関数は引数を二つ取ることが要求されます。第
;;		1引数はそのときに入力されたキーワード、第2引数は何番目の
;;		引数入力かを示す整数が渡されます。
;;		epo-tex.html には、EPOの構造入力で野鳥のアドイン関数を呼
;;		ぶための設定例があります。
;;		(こだわる人向け)
;; 
;; 以下が実際の定義例です。

(defvar epo-example-structure-alist
  '((?b (type . block)
	(structure keyword " (" argument ") {\n" indent cursor "\n" "}" indent)
	(table ("if" "condition") ("for") ("while") ("switch"))
	;;(arg-reader . epo-example-block)
	(mustmatch . t))
    (?f (type . function)
	(structure keyword "(" argument ");")
	(argsep "" "" nil ", " "" ""))))

;; ?b と ?f なので、構造入力補完キー([prefix] C-s)を押すと見にバッファに
;; 以下のように現れます。
;; 
;;	Competion : (b)block (f)function
;; 
;; ここでbを押すとblock構造が、fを押すとfunction構造が選択されます。
;; block構造の 'structure はバッファに挿入されたイメージに直すと以下のよ
;; うになります。
;; 
;;	keyword (argument) {
;;	__□
;;	} (↑ここにカーソル)
;; 
;; また、'arg-reader として 'epo-example-block 関数が指定した場合は
;; 引数の入力時には以下のように作成された関数が呼ばれることになります。
;;
;; (defun epo-example-block (keyword argp)
;;   (cond
;;    ((= argp 1) (read-string (format "%s, condition: " keyword)))))
;; 
;; 二つの引数の利用方法に注意して下さい。
;; 

;; 【反復子自動判別入力のテンプレートalist】
;; 
;; ある言語特有の反復子(繰り返し要素)を補完入力する情報は Emacs-Lisp 変数
;; 
;;	epo-言語名-iteration-alist
;; 
;; に設定します。
;; alistは (任意の1文字 補完リスト) が続く組合せで、先頭の文字は
;; 必ず一意にします。
;; 
;; 「補完リスト」は要素として 'type, 'opener, 'closer, 'iteratorを含む
;; alistです。これはLaTeXとHTML以外ではあまり必要性が無いので、ここでは
;; LaTeX用の例のみ提示し、簡単な説明を加えるにとどめます。

(defvar epo-example-iteration-alist
  '((?i (type . itemize)
	(opener . ((pattern "\\\\begin{itemize}" (!before . comment-start))))
	(closer . ((pattern "\\\\end{itemize}" (!before . comment-start))))
	(iterator . ("\\item ")))
    (?e (type . enumerate)
	(opener . ((pattern "\\\\begin{enumerate}"
			    (!before . comment-start))))
	(closer . ((pattern "\\\\end{enumerate}" (!before . comment-start))))
	(iterator . ("\\item ")))
    (?d (type . description)
	(opener . ((pattern "\\\\begin{description}"
			    (!before . comment-start))))
	(closer . ((pattern "\\\\end{description}"
		   (!before . comment-start))))
	(iterator . (("\\item[" cursor "]"))))
    (?t (type . tabular)
	(opener . ((pattern "\\\\begin{tabular}" (!before . comment-start))))
	(closer . ((pattern "\\\\end{tabular}" (!before . comment-start))))
	(iterator . epoi-tex-enviroment-iterators))))

;; 各補完リストの要素には以下の内容を定義します。
;; 
;; * type	その繰り返しが起きる環境(包括子と呼ぶことにします)の種別
;;		を表すシンボル。
;; * opener, closer	包括子の開始(opener)または終了(closer)記号となる
;;   		構造に関する情報を与えます。与える情報もやはりalist形式
;;		となり、内部に含める要素には以下のものがあります。
;; 
;;		- pattern	パターンの「文脈確認正規表現」を指定しま
;;		  す。文脈確認正規表現とは、正規表現でマッチしたものが位
;;		  置する文脈をさらに調べることで、より正確な構造を検索で
;;		  きるように拡張したものです。たとえば、普通の正規表現で
;;		  は括弧の対応を取るのは困難ですが、文脈確認正規表現では
;;		  それを記述することを容易にします。
;;		- その他
;;		  今のところ opener, closer に与える要素は pattern だけ
;;		  です(拡張予定)。
;; * iterator	その包括子に囲まれた箱の内部で、繰り返すべき入力構造を与
;;		えます。この形式は、先述の structure-alist の 'structure
;;		要素と同じものです。また、要素として関数名を指定すると反
;;		復子の入力にはその関数を呼ぶようになります。関数は一つの
;;		引数をとる必要があり、包括子の開始を意味する文字列が渡さ
;;		れます。たとえば、LaTeXのitemze環境でこの反復子挿入が発
;;		動した場合は、"\begin{itemize}" という文字列が渡ります。
;; 
;; この変数を正しく設定すると [prefix] C-i により、その場にふさわしい反
;; 復子が挿入されます。[prefix] RET とした場合は、改行してから反復子を挿
;; 入します。


;;;
;; ========== Variables for Relation Resolver(EPOR) ==========
;;;

;;;
;; 【関係追跡の情報追跡alist】
;; 
;; ある言語特有の関係(識別子の参照と定義、ファイルインクルード)を司る情
;; 報は Emacs-Lisp 変数
;; 
;;	epo-言語名-relation-alist
;; 
;; に設定します。
;; alistは (任意の1文字 関係情報リスト) が続く組合せで、先頭の文字は
;; 必ず一意にします。
;; 
;; 「関係情報リスト」は要素として 'type, 'idpattern, 'relation, table を
;; 含むalistです。これはあらゆる言語で非常に有効に機能するのできちんと設
;; 定しましょう。
;; 実例を先に示しますので、これと照らし合わせながら各要素の意味を理解し
;; て下さい。

(defvar epo-example-relation-alist
  '((?f (type . reference)
	(idpattern . "[A-Za-z_][0-9A-Za-z_]*")
	(relation
	 (definition
	   (pattern . ("\\<%i\\>" (after . "(") (paren 1 "{")))
	   (group . 0))
	 (reference
	  (pattern . ("\\<%i\\>" (after . "(") (!paren 1 "{")))
	  (group . 0)))
	(table . epo-example-libc-functions))
    ))
;; 
;; * type	「関係」の種別を指定します。種別は以下のうちのどれかです。
;; 
;;		- reference	一つの識別子の参照・被参照関係です。たと
;;		  えば、プログラミング言語における、変数・関数の定義と参
;;		  照がもつお互いの関係は reference です。何か一つの一意
;;		  に定まる単語を仲介として、ソースの、どこかの場所と別の
;;		  場所が結びつけられるとき、それは reference です。LaTeX
;;		  でいえば \label{foo} である場所に foo という名前を付け、
;;		  別の場所で \ref{foo} によってその場所を示すことが出来
;;		  ますが、この関係も reference です。
;; 
;;		- box		ソースのある二つの箇所で挟まれた領域に
;;		  「箱」を形成する二つのペアは、box という関係です。
;;		  LaTeXでいえば \begin{} と \end{} がお互いに持つ関係が
;;		  boxです。
;; 
;;		- file		ソース中で別のファイルを指し示す記法があ
;;		  る場合、その箇所と、指し示されたファイルの関係は file
;;		  です。
;;		
;;		- external	ソースの外部に存在するもの(プロセスやURL
;;		  など)を指し示す関係が external です。ソースに存在しな
;;		  いもので、なおかつ直接編集できないものが主に当てはまり
;;		  ます。これを指定する場合は Emacs-Lisp 変数
;;		  epo-file-processor-alist に対象相手(ファイル名など)の
;;		  パターンと、それを処理するために起動するコマンドの
;;		  alist を指定しておきます。この変数の指定については、
;;		  epop.el を参照して下さい。
;; 
;; * idpattern	関係が reference であるとき、それらを結びつける識別子に
;;		許されたパターンを(普通の)正規表現で指定します。
;;		上記の例の
;;			(idpattern . "[A-Za-z_][0-9A-Za-z_]*")
;;		は、「アルファベットか _ ではじまり、二文字目以降は数字
;;		でも良い(一文字でも可)」というのが識別子命名規則にある場
;;		合の定義例です。
;; 
;; * relation	「関係」によって結びつけられるものは、二つのものです。そ
;;		の二つに関する情報を設定します。最低でも二つの要素を
;;		alistで指定します。この要素は
;; 
;;		  (関係の役名シンボル 関係情報alist)
;; 
;;		という形式で、「関係の役名シンボル」は任意のシンボルです。
;;		他だし、その関係に「定義」と「参照」という意味相賀互い
;;		に存在する場合は、定義する役名に def、参照する役名に ref
;;		を含めておいて下さい。「関係情報alist」には以下の要素を
;;		指定します。
;; 
;;		- pattern	その役割をこなす構文の文脈確認正規
;;		表現(以後CCREと表記)を指定します。CCREの先頭の正規表現文
;;		字列中では %i という表記が使えます。%i は idpattern に置
;;		換されます。また、%i はかならず \\( \\) でグルーピングし
;;		て下さい(検索後に識別子を取り出すために必要です)。
;; 
;;		- group		%i をグルーピングした \\(\\) の番号を整
;;		数で指定します。
;; 
;;		- structure	その役割をこなす構文が発見できなかった場
;;		合に、それを自動的に生成するための構造を与えます。この構
;;		造は、structure-alist の structure と同じ形式です。この
;;		とき、keyword の部分には、reference の元となった識別子が
;;		代入されます。たとえば、Emacs-Lispで何かの関数を記述して
;;		いて、その途中「ここは関数にしよう」と思う箇所があったら、
;;		その場に関数の参照を書いてしまいましょう。そこでEPOの関
;;		係解決機能を呼び出すと、関数定義のテンプレートを作成しま
;;		す。この例は、epo-elisp.el の epo-elisp-relation-alist
;;		にあるので参考にして下さい。
;; 
;; * table	関係が reference の場合、識別子は入力途中でEPOが補完しま
;;		す。その場合の補完候補テーブルを特別に持ちたいときに指定
;;		します。デフォルトでは、作成している言語の複数のソースファ
;;		イルから識別子の定義部分を全て探して、それを候補にします。
;;		この場合ユーザが定義した識別子(関数)しか補完できないこと
;;		になりますが、これ以外にその言語処理系がデフォルトで持つ
;;		関数などを補完候補に含めたいときにこれを指定します。
;;		epo-c.el には、manページの3章にある名前の全てをC言語の
;;		識別子のデフォルト補完候補に含める例があるので参考にして
;;		下さい。
;; 
;; この設定により [prefix] C-r を押すと、その言語固有の「関係」をEPOが追
;; 跡します。関係が reference の場合は相手の場所にポイントを移動し、file
;; の場合はそのファイルに移動し、external の場合は対応プロセスを起動しま
;; す。
;; 
;; また、文書入力中にどこか別箇所で定義されている識別子を入力するときに、
;; その識別子(関数や変数名、ラベル名など)のイニシャルだけを入力した状態
;; で [prefix] C-@ を押すと、その関係の定義を多くのファイルから探し出し
;; て、その識別子名を補完します。
;; 
;; 一つ注意が必要なのは、[prefix] C-@ のカーソル位置補完では、この機能を
;; 呼び出す状態で、その位置が「関係」の片方であることが決定する形式になっ
;; ていなければなりません。たとえば、C言語の変数の参照は
;; 
;;	識別子のパターン
;; 
;; がバッファ中に存在することで判定できますが、関数の場合は
;; 
;;	識別子のパターン(…)
;; 
;; のように直後に丸括弧の組があることを期待しています。しかし普通関数名
;; を入力する段階ではまだ丸括弧を入力する前なので、[prefix] C-@ を途中で
;; 押しても、それは変数参照の位置だと思われてしまいます。これはC系列の言
;; 語特有の問題であるため、特別に [prefix] C-f を用意しています。こちら
;; のキーは、自動的に直後に () を補ってから [prefix] C-@ を呼び出します。
;; つまり、C系列言語の関数呼び出しを補完するための単なる便利キーです。
;; 
;; また、「関係」として file, box のいずれかにカーソルを合わせて
;; [prefix] C-c を押すと、それらの対応を取っている名前を変更します。たと
;; えば、\include{hoge} で hoge ファイルを関係づけている場合、hogeの位置
;; で [prefix] C-c を押すとその位置の hoge という表記と、それによって指
;; し示されるファイル hoge の名前を同時に変更します。

;;;
;; ========== Variables for Process Handler(EPOP) ==========
;;;
;;;
;; 【言語処理系の起動情報のalist】
;; 
;; ある言語で書いたソースを実際に目的物に変換したり、吟味したりするため
;; に起動する外部プロセスの情報は Emacs-Lisp 変数
;; 
;;	epo-言語名-process-alist
;; 
;; に設定します。
;; alistは (任意の1文字 プロセス情報リスト) が続く組合せで、先頭の文字は
;; プロセス起動メニューでどれを起動するかの入力キーとして利用されます。
;; 
;; 「プロセス情報リスト」は要素として 'type, 'command, 'prompt, 'builtin 
;; を含むalistです。prompt, builtin は省略可能です。
;; 
;; * type	その外部プロセスが行う処理の種別を示すシンボルを指定しま
;;		す。今のところ任意のシンボルが指定できますが、将来これに
;;		意味を持たせるかもしれません。とりあえずは compile, run,
;;		preview などにしておいて下さい。
;; * command	その外部プロセスを起動するコマンドライン情報を指定します。
;;		コマンドライン情報はリストで構成します。先頭要素は
;;		
;; 
;;		1.	コマンドの働きを示す説明文字列を(なるべく短く)指定
;;		2.	その処理系のコマンド名を指定します
;;		3以降	コマンドに与える引数を指定します。
;;			引数には次のシンボルが使えます。
;;			- filename	ファイル名に置換されます。
;;			- basename	ファイル名のうちディレクトリ名を
;;					取り除いた名前に置換されます。
;;			- rootname	basenameからさらに拡張子を取り除
;;					いた名前に置換されます。
;;			- dirname	ファイルがあるディレクトリ名
;;			- text		テキストに置換されます
;;			- magic		ファイル先頭にある #! 行から必要
;;					なコマンドラインを作りそれに置き
;;					換えます。
;; 
;;			これらのシンボルが意味する文字列のうち、さらにそ
;;			の一部だけを取り出したいときは正規表現による置き
;;			換え規則が記述できます。これを書きたい場合は、
;;			
;;				(上記のシンボル "正規表現" "置き換え表現")
;;			
;;			のように記述します。以下の例は、現在のファイル名
;;			の拡張子を .tex から .dvi に変えて dvi2ps を起動
;;			するための command 要素定義です。
;;			
;;				(command "printing" "dvips"
;;				   (basename "\\(.*\\)\\.tex$" "\\1.dvi"))
;; 
;;			\\N (Nは整数)は元の正規表現のグループ番号Nにマッ
;;			チしたものに置き換えられます。
;; 
;; * prompt	そのプロセスを起動するときに、EPOが判断して生成したコマ
;;		ンドラインをミニバッファに表示して一時停止する場合にはこ
;;		れを Non-nil に設定します。
;; 
;; * builtin	EPOが process-alist を元に自動的に生成するコマンドライン
;;		ではなく、特定のソース独自の処理コマンドを、ソース自身に
;;		埋め込むことが出来ます。たとえばソースを分割しているとき
;;		に、そのソースではなくmainとなる方の別ソースをコンパイラ
;;		に渡すような場合が挙げられます。この場合、コマンドライン
;;		を埋め込むときのキーワード(prefix)を builtin 要素に指定
;;		します。
;;			(builtin . "#!")
;;		
;;		と指定すると、その言語のコメント開始文字列の直後に "#!" 
;;		があったときに、それより後ろの行末まで(またはコメント終
;;		端文字列まで)をその処理を行うコマンドラインとして利用し
;;		ます。Emacsでは、通常その言語のコメント開始文字列と終端
;;		文字列はそれぞれ、Emacs-Lisp 変数 comment-start および
;;		comment-end に入っています。たとえばC言語の 
;;		comment-start は "/* "、comment-end は " */" なので、Cの
;;		ソース中に
;;		
;;			/* #! cc -o hoge main.c hoge.c */
;;		
;;		と書いておけばそのファイルのコンパイルするときだけは
;;		"cc -o hoge main.c hoge.c"
;;		を起動するようになります。
;; 
;; これらを設定したものが以下の例となります。

(defvar epo-example-process-alist
  '((?j (type . compile) (command "Compile" "make" rootname)
	(builtin . "#!"))
    (?r (type . run) (prompt . t)
	(command "run-it" (basename "\\(.*\\)\\.c" "./\\1"))))
  "*Some language dependent process alists")

;; この設定により [prefix] C-t を押すと、処理系コマンド起動メニューとし
;; て
;;	Start process: (j)Compile (r)run-it:
;; 
;; と表示され、jまたはrで各プロセスがとなりのウィンドウで起動します。

;; 【言語処理系のエラー出力情報のalist】
;; 
;; ある言語で書いたソースを処理系を用いて目的物に変換したり、文法試験し
;; たりするときに、その処理系が標準出力に表示するエラー情報は Emacs-Lisp 
;; 変数
;; 
;;	epo-言語名-tagjump-alist
;; 
;; に設定します。
;; alistは (処理名 エラーメッセージ情報リスト) が続く組合せで、「処理名」
;; は process-alist の command 要素の先頭に指定した、コマンドの機能の説
;; 明文字列を指定します。それに対応する言語処理系が吐き出すエラーメッセー
;; ジに関する情報を「エラーメッセージ情報リスト」に指定します。
;; 
;; 「エラーメッセージ情報リスト」は、'type, 'pattern, 'matchinfo を含む
;; alistで指定します。それぞれの要素の意味は以下の通りです。
;; 
;; * type	処理系が出すエラーメッセージ中、解析中のファイル名を表示
;;		する方式を指定します。方式には以下の種別があります。
;;		
;;		- inline	Cコンパイラのように、メッセージの一行に
;;				ファイル名とエラーの両方を表示するタイプ。
;;		- paren		TeXのタイプセッタのように、ファイルの処
;;				理が始まると同時に開き括弧 ( を表示し、
;;				そのファイルの解析が終わると閉じ括弧 )
;;				を表示するタイプ。
;;		- current	単一ファイルを解析することが前提となって
;;				いる処理系で、処理中のファイル名を一切出
;;				力しないタイプ。
;;
;; * pattern	エラー発生行を示す正規表現を指定する。利便のため、この正
;;		規表現中では行番号を表す正規表現として %l を利用できます。
;;		type が inline の場合には、ファイル名および行番号を示す
;;		パターンを \\( \\) によりグループ化する必要があります。
;;
;; * matchinfo	上記の pattern 要素で指定した正規表現中から、ファイル名
;;		と行番号部分に相当するグループ番号をコンスセルで指定しま
;;		す。
;; 
;; たとえば、以下の例

(defvar epo-example-tagjump-alist
  '(("Compile" (type . inline) (pattern . "\\(\\S +\\.c\\):\\(%l\\):")
     (matchinfo 1 . 2))))

;; は、処理系のエラー出力が inline タイプであり、エラー行は
;; 
;;	非空白文字.c:行番号:
;; 
;; というパターンで表示され、そのうち正規表現グループの 1番と2番 がそれ
;; ぞれファイル名と行番号に相当することを意味します。 
;;
;; この設定により [prefix] ' を押すと、処理系が出力したエラーメッセージ
;; を元に、エラー発生行に移動します。
;; 

;; 【言語ソースファイルのファイル情報のalist】
;; 
;; その言語のソースファイルの拡張子や、置き場所(検索場所)に関する情報は、
;; 
;;	epo-言語名-file-alist
;; 
;; という名前のEmacs-Lisp変数に保存します。このalistに設定できる要素は現
;; 在のところ3つです。
;; 
;; * extension		デフォルトの拡張子を指定します。
;; * search		ソースファイルを検索するディレクトリのリストを指
;;			定します。変数名を指定すると、その変数の値を利用
;;			します。このリスト中に存在しなくても、カレントディ
;;			レクトリは常に検索対象に含まれます。
;; * recursive-search	上記のリストを起点に、各ディレクトリを再帰的に下
;;			降して検索するかどうかを指定します。再帰検索する
;;			場合は non-nil を指定します。
;; 
(defvar epo-example-file-alist
  '((extension . ".el")
    (search . load-path)
    (recursive-search . nil)
    ))
;; 
;; 
;;	-	-	以上で必要な情報は全てです。	-	-
;; 
;; 
;; 全てのalist変数定義が終わったら最後に provide して下さい。
;; provide名はファイル名と同じにします。

(provide 'epo-example)

; Local variables: 
; fill-prefix: ";;	" 
; paragraph-start: "^$\\|\\|;;$" 
; paragraph-separate: "^$\\|\\|;;$" 
; End: 
